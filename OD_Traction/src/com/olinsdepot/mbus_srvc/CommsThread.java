package com.olinsdepot.mbus_srvc;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import java.net.Socket;
import java.nio.ByteBuffer;

import java.util.Arrays;
import java.util.Timer;
import java.util.TimerTask;

import android.util.Log;
import android.util.SparseArray;

import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Message;
import android.os.Messenger;
import android.os.Process;
import android.os.RemoteException;


/**
 * CommsThread opens a socket on the remote MorBus server and sets up receive and transmit
 * threads to communicate with the server over the LAN. Commands passed down from the MorBus
 * service are wrapped as EmCAN stream commands and sent to the server. The server responses
 * are parsed and resulting events generated are passed up to the MorBus service layer.
 * 
 * @author mhughes
 *
 */
public class CommsThread extends Thread {
	private final String TAG = getClass().getSimpleName();
	private static final boolean L = true;

	/**
	 * Commands supported by Comms thread
	 */
	public static enum CommsCmd {
		SND_STREAM,
		SND_BCST,
		SND_PORT,
		CLOSE;
		
		/* Returns the code for this Comms command. */
		public int toCode() {
			return this.ordinal();
		}
		
		/* Returns the Comms command for the code passed. */
		public static CommsCmd fromCode(int indx) {
			return CommsCmd.values()[indx];
		}
	}
	
	/**
	 * Events generated by Comms Thread
	 */
	public static enum CommsEvt {
		START,
		STOP,
		CONNECT;
		
		/* Returns the code for this Comms event */
		public int toCode() {
			return this.ordinal();
		}
		
		/* Returns the Comms Event for the code passed. */
		public static CommsEvt fromCode(int indx) {
			return CommsEvt.values()[indx];
		}
	}
	
	/*
	 * Network connection to the remote MorBus server.
	 */
	private final Socket mSocket;
	private final InputStream inputStream;
	private final OutputStream outputStream;
	
	/*
	 * Message thread to decompose commands from the MorBus service to EmCAN commands to send
	 * to the remote server. The service posts commands on the CommsSendHandler message queue.
	 */
	private static HandlerThread mCommsSendThread;
	private static Looper mCommsSendLooper;
	private static Handler mCommsSendHandler;

	/* 
	 * Keep alive thread
	 */
	static final int UPDATE_INTERVAL = 50000;
	private Timer keepLiveTimer = new Timer();

	/*
	 *  Server state shared with the send and receive threads
	 */
	private enum SrvStates {
		INIT,	// Not connected to server yet
		READY,	// Connected, accepting commands
		BUSY	// Connected, waiting for a command to complete
	}
	
	/*
	 * Synchronize the server state between the transmit and receive threads.
	 */
	private  class SrvrState {
		
		private SrvStates myState;
		
		SrvStates get() {
			return myState;
		}
		
		SrvStates set(SrvStates state) {
			myState = state;
			return myState;
		}
	}
	SrvrState mSrvrState = new SrvrState();
	
	/*
	 * Various EmCAN commands and responses.
	 */
	
	/**
	 * EMCAN stream op codes.
	 */
	private static enum EmCanCmd {
		NOP 		(0),
		PING 		(1),
		ID 			(2),
		FWINFO		(3),
		CMDS		(4),
		RESET		(5),
		SENDS		(6),
		SENDE		(7),
		SENDSR		(8),
		SENDER		(9),
		ENUM		(10),
		KEEPALIVE	(11),
		STROUT		(12);
		
		/* Constructor */
		private final int opcode;		
		private EmCanCmd(int op) {
			this.opcode = op;
		}
		
		/* Returns the code for this EmCAN command */
		public byte toCode() {
			return (byte) this.opcode;
		}
	}

	/**
	 * EMCAN Stream response codes
	 */
	private static enum EmCanRsp {
		EOF			(-1),
		NOP			(0),
		PONG		(1),
		ID			(2),
		FWINFO		(3),
		CMDS		(4),
		CANFR		(5),
		RESET		(6),
		ADR			(7),
		UNADR		(8),
		STROUT		(9),
		STRINRES	(10),
		STRIN		(11);
		
		/* Constructor */
		private final int rspcode;
		private EmCanRsp(int rsp) {
			this.rspcode = rsp;
		}

		/* Create map of values to Enum */
		private static final SparseArray<EmCanRsp> codeToEnum = new SparseArray<EmCanRsp>();
		static {
			for (EmCanRsp rsp : values()) {
				codeToEnum.put(rsp.toCode(), rsp);				
			}
		}
		
		/* Returns the code for this EmCAN response. */
		public int toCode() {
			return this.rspcode;
		}
		
		/* Returns EmCAN response for the code passed, or null if code is invalid */
		public static EmCanRsp fromCode(int rsp) {
			return codeToEnum.get(rsp);
		}
	}
	
	/**
	 * Standard Frame Opcodes
	 */
	private static enum StndFrmOp {
		RESET		(0),
		ADRASSIGN	(8),
		SYNC		(12),
		ADRELEASE	(13),
		ADRREQ		(14),
		ADRREQRES	(15);
		
		/* Constructor */
		private final int stdidop;
		private StndFrmOp(int op) {
			this.stdidop = op;
		}
		
		/* Returns the op code for this EmCAN extended frame operation */
		public int toCode() {
			return this.stdidop;
		}
	}
	
	/**
	 * Extended Frame Opcodes
	 */
	private static enum ExtdFrmOp {
		PORTWR		(992),
		PORTRD		(993),
		FWINFO		(1008),
		APPROLE		(1009),
		CONFIG		(1011),
		NPORTS		(1012),
		PORTYPE		(1013),
		PORTSCALE	(1014),
		PORTOFS		(1015),
		SETROLE		(1018),
		PORTINIT	(1019),
		PORTCFG		(1020),
		PORTROLE	(1021),
		STROUT		(1022),
		STRIN		(1023);
		
		/* Constructor */
		private final int extidop;
		private ExtdFrmOp(int op) {
			this.extidop = op;
		}
		
		/* Returns the op code for this EmCAN  extended operation */
		public int toCode() {
			return this.extidop;
		}
	}
	
	
	/**
	 * EmCAN ID field bit definitions
	 */
	private static enum ExtdFrmFlg {
		NEW_DATA			(1 << 16),
		UNSOLICITED			(1 << 15),
		ACK_REQSTD			(1 << 14),
		CONTINUATION		(1 << 13),
		TO_BE_CONTINUED		(1 << 12);
		
		/* Constructor */
		private final int idflgs;
		private ExtdFrmFlg(int flg) {
			this.idflgs = flg;
		}
		
		/* Returns the flag */
		public int toCode() {
			return this.idflgs;
		}
	}
	
	
	/**
	 * Comms Thread constructor: Opens stream and starts transmit thread
	 * 
	 * @param sock - socket of target server.
	 */
	public CommsThread(Socket sock) {
		
		// Init server state
		mSrvrState.set(SrvStates.INIT);

		mSocket = sock;
		InputStream tmpIn = null;
		OutputStream tmpOut = null;

		this.setName("SrvrMsgRcv");
		
		// create input and output stream objects to read and write socket.
		try {
			tmpIn = mSocket.getInputStream();
			tmpOut = mSocket.getOutputStream();
		}
		catch (IOException e) {
			Log.d(TAG, e.getLocalizedMessage());
		}
		inputStream = tmpIn;
		outputStream = tmpOut;
		
		// Start the thread to send to the server
		mCommsSendThread = new HandlerThread("SrvrMsgSnd", Process.THREAD_PRIORITY_BACKGROUND);
		mCommsSendThread.start();
		mCommsSendLooper = mCommsSendThread.getLooper();
		mCommsSendHandler = new CommsSendHandler(mCommsSendLooper);

		// Send "START" event to Morbus service with the Comm thread's message handler.
		Message msg = MbusService.mCommsToSrvcHandler.obtainMessage(CommsEvt.START.ordinal(), 0, 0);
		msg.replyTo  = new Messenger(mCommsSendHandler);
        MbusService.mCommsToSrvcHandler.sendMessage(msg);
	}
	

	/**
	 * Comms Receive Thread: Parses packet from server and generates an
	 * event to send to the client.
	 */
	public void run() {
		String TAG = "CommsRcv";
		

		final byte[] PROT_NAME = {'E','m','C','a','n',':','M','o','r','B','u','s'};
		int protVersion = 0;

		byte rspCode = 0;					    // read expected response code.
		byte[] rcvBuf = new byte[1024];		// buffer store for the stream
		int bytes = 0;		                // number of bytes returned from read
		
		while(true) {
			//Make a blocking call to read response code from input stream.
			try {
				rspCode = (byte)inputStream.read();				
			}
			catch (IOException e) {
				Log.d(TAG, e.getLocalizedMessage());
				//TODO Send message to service that read on socket failed.
			}			

			// Dispatch received response code
			switch (EmCanRsp.fromCode(rspCode)) {
			
			case EOF:
				if (L) Log.i(TAG, "Reached EOF");
				break;
			
			case NOP:
				if (L) Log.i(TAG, "Received NOP");
				break;
			
			case PONG:
				if (L) Log.i(TAG, "Received PONG");
				// If server was BUSY, receiving PONG indicates it's now READY
				if (mSrvrState.get() == SrvStates.BUSY) {
					mSrvrState.set(SrvStates.READY);
				}
				break;
			
			case ID:
				if (L) Log.i(TAG, "Received ID");
				// Process this response if the server is not already connected, else - ignore it.
				if (mSrvrState.get() == SrvStates.INIT) {
					
					//Read rest of the ID response...
					for (bytes = 0; bytes < 1024; bytes++) {
						try {
							rcvBuf[bytes] = (byte)inputStream.read();
						} catch (IOException e) {
							Log.d(TAG, e.getLocalizedMessage());
						}
						if (rcvBuf[bytes] == 0) break;
					}
					
					//  ...and verify isequal EmCan:Morbus
					byte[] rcvdId = Arrays.copyOf(rcvBuf,bytes);
					if (Arrays.equals(rcvdId, PROT_NAME)) {
							
						//Read the protocol version.
						try {
							protVersion = inputStream.read();
						} catch (IOException e) {
							Log.d(TAG, e.getLocalizedMessage());
						}
	
						// Send "Connect" event to Morbus service. Attach the server's message handler.
						Message msg = MbusService.mCommsToSrvcHandler.obtainMessage(CommsEvt.CONNECT.ordinal());
						msg.arg1 = 0; //Event is success
						msg.arg2 = protVersion; // Report protocol version.
		                MbusService.mCommsToSrvcHandler.sendMessage(msg);
		                
		                // Update server state to "Connected, ready for commands"
			                mSrvrState.set(SrvStates.READY);

		                //Start a thread to send keep alive commands every 50 seconds
						KeepAliveThread();
					}
				}
				break;
			
			case FWINFO:
				if (L) Log.i(TAG, "Received FWINFO");
				break;
			
			case CMDS:
				if (L) Log.i(TAG, "Received CMDS");
				break;
			
			case CANFR:
				if (L) Log.i(TAG, "Received CANFR");
				break;
			
			case RESET:
				if (L) Log.i(TAG, "Received RESET");
				break;
			
			case ADR:
				if (L) Log.i(TAG, "Received ADR");
				break;
			
			case UNADR:
				if (L) Log.i(TAG, "Received UNADR");
				break;
			
			case STROUT:
				if (L) Log.i(TAG, "Received STROUT");
				break;
			
			case STRINRES:
				if (L) Log.i(TAG, "Received STRINRES");
				break;

			case STRIN:
				if (L) Log.i(TAG, "Received STRIN");
				break;

			default:
				Log.d(TAG,"Unknown EMCan response");
				break;
				
			}	// end switch	
		}	// end while
	}

	/**
	 *  Comms Send Thread: Parses command from service and generates a
	 *  packet to send to the server.
	 *  
	 *  @param msg - Message from Main containing an MBus event.
	 */
	private final class CommsSendHandler extends Handler {
		
		private ByteBuffer sndBuf;
		private byte[] datBuf;
		
		// Constructor
		public CommsSendHandler(Looper looper) {
			super(looper);
		}
		
		// Message handler
		@Override
		public void handleMessage(Message msg) {
			if (L) Log.i("CommsSendHandler", "Message type " + msg.what);
			
			/*Spin waiting for server state to be READY.
			while (mSrvrState.get() != SrvStates.READY) {
				try {
					mSrvrState.wait();
				} catch (InterruptedException e) {
					Log.d(TAG, e.getLocalizedMessage());
				}			

			}
			*/
			
			// Dispatch this send command
			switch (CommsCmd.fromCode(msg.what)) {
			
			/* Send the Byte Stream Protocol opcode byte passed in ARG1. */
			case SND_STREAM:
				sndBuf = ByteBuffer.allocate(1);
				sndBuf.put((byte)msg.arg1);
				write(sndBuf.array());
				break;

			/* Send a broadcast extended EmCAN frame with ARG1 = opcode, OBJ = data. */
			case SND_BCST:
				
				/* Get the data & create a send buffer, based on data length. */
				datBuf = (byte[]) msg.obj;
				// TODO add check on length of datBuf.
				sndBuf = ByteBuffer.allocate(6 + datBuf.length);
				
				/* Build the EmCAN frame. */
				sndBuf.put(EmCanCmd.SENDE.toCode());	/* stream command */
				sndBuf.put((byte) datBuf.length);		/* # of CAN data bytes */
				sndBuf.putInt(getExID(msg.arg1, 0));		/* generate EmCAN ID */
				sndBuf.put(datBuf);						/* CAN data */

				write(sndBuf.array());

				break;
			
			/* Send a port specific EmCAN frame with ARG1 = opcode, ARG2 = node, OBJ = data. */
			case SND_PORT:
				break;
				
			/* Close the socket. */
			case CLOSE:
				cancel();
				break;
				
			default:
				Log.d("CommsSendHandler", "Unknown MBus event type " + msg.what);
				super.handleMessage(msg);
			}
		}
	}


	/**
	 * CommsThread Write Method
	 * Write a string of bytes to the output stream.
	 * 
	 * @param bytes - byte array to send
	 */
	private void write(byte[] bytes)
	{
		try {
			outputStream.write(bytes);
		}
		catch (IOException e) {
			Log.d(TAG, e.getLocalizedMessage());
			//TODO Send message to service that write on socket failed.
		}
	}


	/**
	 * CommsThread Cancel Method
	 * Close the socket
	 */
	private void cancel()
	{
		try {
			mSocket.close();
		}
		catch (IOException e) {
			Log.d(TAG, e.getLocalizedMessage());
		}
	}
	
	/**
	 * Return a 32 bit integer containing the 32 bit extended ID
	 * for an EmCAN external stream frame.
	 */
	private int getExID(int op, int node) {
		int emcanId = 0;
		// TODO right now, only supports broadcast.
		
		if (node == 0) {
			emcanId |= (op << 19);
			emcanId |= ExtdFrmFlg.NEW_DATA.toCode();
		}
		
		return emcanId;
	}

	/**
	 * Keep Alive Thread. Posts a keep-alive message to the send queue every 50 seconds.
	 *
	 */
	private void KeepAliveThread () {
		keepLiveTimer.scheduleAtFixedRate(new TimerTask() {
			public void run() {
				Log.d(TAG, "KeepAliveTask");
				if (L) Log.i("CommsSendHandler", "Sending Keep_alive");
				
				byte[] sndBuf = new byte[1];
				sndBuf[0] = EmCanCmd.KEEPALIVE.toCode();
				write(sndBuf);
			}
		}, 0, UPDATE_INTERVAL);
	}
	
	/**
	 * Bytes to Hex String: Utility function
	 * @param Byte array
	 */
	final protected static char[] hexArray = "0123456789ABCDEF".toCharArray();

	public static String bytesToHex(byte[] bytes) {
	    char[] hexChars = new char[bytes.length * 2];

	    for ( int j = 0; j < bytes.length; j++ ) {
	        int v = bytes[j] & 0xFF;
	        hexChars[j * 2] = hexArray[v >>> 4];
	        hexChars[j * 2 + 1] = hexArray[v & 0x0F];
	    }

	    return new String(hexChars);
	}

}
